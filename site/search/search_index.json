{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AmeisenBot A bot for WoW 3.3.5a 12340 At this time this bot is only a playground for me to learn and test stuff, but it will get more and more stable in the near future.","title":"AmeisenBot"},{"location":"#ameisenbot","text":"","title":"AmeisenBot"},{"location":"#a-bot-for-wow-335a-12340","text":"At this time this bot is only a playground for me to learn and test stuff, but it will get more and more stable in the near future.","title":"A bot for WoW 3.3.5a 12340"},{"location":"ameisencore/AmeiseBot.Core/","text":"AmeisenBot.Core This project contains some of the core functionalities for the bot. AmeisenCore AmeisenHook AmeisenEventHook AmeisenCore This is a class that contains a collection of things the bot can do. AmeisenHook This class is responsible for the D3D9Endscene-Hook stuff. AmeisenEventHook This class captures the events fired inside WoW's ecosystem.","title":"AmeisenBot.Core"},{"location":"ameisencore/AmeiseBot.Core/#ameisenbotcore","text":"This project contains some of the core functionalities for the bot. AmeisenCore AmeisenHook AmeisenEventHook","title":"AmeisenBot.Core"},{"location":"ameisencore/AmeiseBot.Core/#ameisencore","text":"This is a class that contains a collection of things the bot can do.","title":"AmeisenCore"},{"location":"ameisencore/AmeiseBot.Core/#ameisenhook","text":"This class is responsible for the D3D9Endscene-Hook stuff.","title":"AmeisenHook"},{"location":"ameisencore/AmeiseBot.Core/#ameiseneventhook","text":"This class captures the events fired inside WoW's ecosystem.","title":"AmeisenEventHook"},{"location":"ameisencore/AmeisenCore/","text":"AmeisenCore In this class you can find a collection of static methods to interact with the WoW Process & it's functions. Attention You need to set the static Blackmagic instace before you use anything, otherwise it won't work properly. This instance is used in 90% of the actions. For some actions you need to Hook WoW's Endscene function to execute stuff on WoW's main thread if you use one of these methods, please set the static Property of AmeisenHook to a hooked instance of the AmeisenHook class. Methods","title":"AmeisenCore"},{"location":"ameisencore/AmeisenCore/#ameisencore","text":"In this class you can find a collection of static methods to interact with the WoW Process & it's functions.","title":"AmeisenCore"},{"location":"ameisencore/AmeisenCore/#attention","text":"You need to set the static Blackmagic instace before you use anything, otherwise it won't work properly. This instance is used in 90% of the actions. For some actions you need to Hook WoW's Endscene function to execute stuff on WoW's main thread if you use one of these methods, please set the static Property of AmeisenHook to a hooked instance of the AmeisenHook class.","title":"Attention"},{"location":"ameisencore/AmeisenCore/#methods","text":"","title":"Methods"},{"location":"ameisencore/AmeisenEventHook/","text":"","title":"AmeisenEventHook"},{"location":"ameisencore/AmeisenHook/","text":"AmeisenHook This is the class that manages the hookig of WoW's D3D9 Endscene function. We will hook it to execute functions on WoW's main thread. This funtion is called after every frame, so if we're at a framerate of 60 we have 60 executions per second which is enough for what it is beeing used for at the moment. Preperation Getting the endscene address First we need to know where to apply our memory-modification (where the endscene is located). Example code with 3.3.5a offsets: public readonly uint devicePtr1 = 0xC5DF88; public readonly uint devicePtr2 = 0x397C; public readonly uint endScene = 0xA8; uint pDevice = BlackMagic.ReadUInt(Offsets.devicePtr1); uint pEnd = BlackMagic.ReadUInt(pDevice + Offsets.devicePtr2); uint pScene = BlackMagic.ReadUInt(pEnd); uint endscene = BlackMagic.ReadUInt(pScene + Offsets.endScene); Using the found offset Now that we know where our functions is located we need to search for the first thing with a size of 5 bytes. Why 5 bytes, thats because we're going to place a JMP instruction at this place and as we know a JMP plus Address to jump to are 1 + 4 bytes on a 32Bit system. So lets do it, our memory at the endscene address should look like this: to be added... As you might see there is something that's 5 bytes big, but it's offsetted by 0x2. That's no problem for us, we will just add that on top of our endscene public const uint ENDSCENE_OFFSET = 0x2; uint endscene += ENDSCENE_OFFSET; So far so good, we know where to apply our hook but how do we do it, what are we going to do? Jump from endscene function to our own instructions Check if there is anything to execute If there is something, execute it otherwise do nothing After that return to the original like nothing happened Codecaves Enough thinking, lets get down to business. First we need a place to store our Instrctions in the memory of WoW. uint codeCave = BlackMagic.AllocateMemory(64); uint codeCaveForInjection = BlackMagic.AllocateMemory(256); codeCave : will be the place where we check if there are instructions to run. codeCaveForInjection : will be the place where we place our instructions that we want to execute So far so good but how will we know that the code was executed? And what about return values? Don't worry its simple, just reserve two integers in WoW's memory. uint codeToExecute = BlackMagic.AllocateMemory(4); uint returnAdress = BlackMagic.AllocateMemory(4); BlackMagic.WriteInt(codeToExecute, 0); BlackMagic.WriteInt(returnAdress, 0); codeToExecute : will hold 1 or 0 whether there is or isn't anything to execute returnAdress : will be a pointer to the data returned by the function we called We're finished with our preperational stuff. Assembly instructions Check for instructions to execute By now we've got everything prepared for our hook, so let's crawl through some Assembly. Step one, the code that checks for instructions to be executed, we don't want to change anything that WoW can continue to work after we've done our stuff. Thats a problem because we will change something, there's no way of not doing that. So what wre we going to do about that? PUSHFD , POPFD , PUSHAD & POPAD , that are the instructions we need. Simplified explanation : PUSHFD & PUSHAD will save our registers POPFD & POPAD will restore our registers PUSHFD PUSHAD // our instructions will end up here POPAD POPFD Now we're able to start the implementation of the \"check for instructions\" part. There are 9 steps to do that i've broke down into 3x3: Load the value of codeToExecute into EBX Compare EBX (the value of codeToExecute) to 1 If there is no code jump to @out (we will declare it later) {(codeToExecute)} : replace that with you codeToExecute variable MOV EBX, [{(codeToExecute)}] TEST EBX, 1 JE @out Load the instructions position into EDX Execute our custom instructions Set the value of our returnAdress to the value of EAX -> at this point EAX contains our return-value pointer and we want to save that for later {(codeCaveForInjection)} : replace that with you codeCaveForInjection variable {(returnAdress)} : replace that with you returnAdress variable MOV EDX, {(codeCaveForInjection)} CALL EDX MOV [{(returnAdress)}], EAX Declare our @out anker that we will jump to if there is nothing to execute Set EDX to 0 set the value of codeToExecute to EDX (0) to signal that we are done {(codeToExecute)} : replace that with you codeToExecute variable @out: MOV EDX, 0 MOV [{(codeToExecute)}], EDX Your finished code should now look something like this: PUSHFD PUSHAD MOV EBX, [{(codeToExecute)}] TEST EBX, 1 JE @out MOV EDX, {(codeCaveForInjection)} CALL EDX MOV [{(returnAdress)}], EAX @out: MOV EDX, 0 MOV [{(codeToExecute)}], EDX POPAD POPFD These Instructions will be placed in the first codeCave that we've allocated, you can inject it using Blackmagic like this: BlackMagic.Asm.Clear(); foreach (string s in asm) { BlackMagic.Asm.AddLine(s); } int asmLenght = BlackMagic.Asm.Assemble().Length; BlackMagic.Asm.Inject(codeCave); If you've done all of this there're only two things left to be done: Execute the original endscene stuff Return to the original function BlackMagic.WriteBytes(codeCave + (uint)asmLenght, originalEndscene); BlackMagic.Asm.Clear(); BlackMagic.Asm.AddLine($\"JMP {(endsceneReturnAddress)}\"); BlackMagic.Asm.Inject((codeCave + (uint)asmLenght) + 5); First we are going to place the original EndScene instructions below our injected ones. You should be able to read the original bytes like this: byte[] originalEndscene = BlackMagic.ReadBytes(endscene, 5); or use mine (they might not work for you, first method is safer) byte[] originalEndscene = new byte[] { 0xB8, 0x51, 0xD7, 0xCA, 0x64 }; After this we want to return to the place where we came from: JMP {(endsceneReturnAddress)} uint endsceneReturnAddress = endscene + 5; Now we will return after the instruction that we will replace in a moment to finally hook WoW's EndScene. Let's replace the original instructions with the one that jumps to our codeCave. JMP {(codeCave)} BlackMagic.Asm.Clear(); BlackMagic.Asm.AddLine($\"JMP {(codeCave)}\"); BlackMagic.Asm.Inject(endscene); Congratulations, you hooked WoW's EndScene and it doesn't do anything. But don't worry the hardest part is done, we just need to inject the code we wan't to execute to the codeCaveForInjection and set codeToExecute to 1. to be continued...","title":"AmeisenHook"},{"location":"ameisencore/AmeisenHook/#ameisenhook","text":"This is the class that manages the hookig of WoW's D3D9 Endscene function. We will hook it to execute functions on WoW's main thread. This funtion is called after every frame, so if we're at a framerate of 60 we have 60 executions per second which is enough for what it is beeing used for at the moment.","title":"AmeisenHook"},{"location":"ameisencore/AmeisenHook/#preperation","text":"","title":"Preperation"},{"location":"ameisencore/AmeisenHook/#getting-the-endscene-address","text":"First we need to know where to apply our memory-modification (where the endscene is located). Example code with 3.3.5a offsets: public readonly uint devicePtr1 = 0xC5DF88; public readonly uint devicePtr2 = 0x397C; public readonly uint endScene = 0xA8; uint pDevice = BlackMagic.ReadUInt(Offsets.devicePtr1); uint pEnd = BlackMagic.ReadUInt(pDevice + Offsets.devicePtr2); uint pScene = BlackMagic.ReadUInt(pEnd); uint endscene = BlackMagic.ReadUInt(pScene + Offsets.endScene);","title":"Getting the endscene address"},{"location":"ameisencore/AmeisenHook/#using-the-found-offset","text":"Now that we know where our functions is located we need to search for the first thing with a size of 5 bytes. Why 5 bytes, thats because we're going to place a JMP instruction at this place and as we know a JMP plus Address to jump to are 1 + 4 bytes on a 32Bit system. So lets do it, our memory at the endscene address should look like this: to be added... As you might see there is something that's 5 bytes big, but it's offsetted by 0x2. That's no problem for us, we will just add that on top of our endscene public const uint ENDSCENE_OFFSET = 0x2; uint endscene += ENDSCENE_OFFSET; So far so good, we know where to apply our hook but how do we do it, what are we going to do? Jump from endscene function to our own instructions Check if there is anything to execute If there is something, execute it otherwise do nothing After that return to the original like nothing happened","title":"Using the found offset"},{"location":"ameisencore/AmeisenHook/#codecaves","text":"Enough thinking, lets get down to business. First we need a place to store our Instrctions in the memory of WoW. uint codeCave = BlackMagic.AllocateMemory(64); uint codeCaveForInjection = BlackMagic.AllocateMemory(256); codeCave : will be the place where we check if there are instructions to run. codeCaveForInjection : will be the place where we place our instructions that we want to execute So far so good but how will we know that the code was executed? And what about return values? Don't worry its simple, just reserve two integers in WoW's memory. uint codeToExecute = BlackMagic.AllocateMemory(4); uint returnAdress = BlackMagic.AllocateMemory(4); BlackMagic.WriteInt(codeToExecute, 0); BlackMagic.WriteInt(returnAdress, 0); codeToExecute : will hold 1 or 0 whether there is or isn't anything to execute returnAdress : will be a pointer to the data returned by the function we called We're finished with our preperational stuff.","title":"Codecaves"},{"location":"ameisencore/AmeisenHook/#assembly-instructions","text":"","title":"Assembly instructions"},{"location":"ameisencore/AmeisenHook/#check-for-instructions-to-execute","text":"By now we've got everything prepared for our hook, so let's crawl through some Assembly. Step one, the code that checks for instructions to be executed, we don't want to change anything that WoW can continue to work after we've done our stuff. Thats a problem because we will change something, there's no way of not doing that. So what wre we going to do about that? PUSHFD , POPFD , PUSHAD & POPAD , that are the instructions we need. Simplified explanation : PUSHFD & PUSHAD will save our registers POPFD & POPAD will restore our registers PUSHFD PUSHAD // our instructions will end up here POPAD POPFD Now we're able to start the implementation of the \"check for instructions\" part. There are 9 steps to do that i've broke down into 3x3: Load the value of codeToExecute into EBX Compare EBX (the value of codeToExecute) to 1 If there is no code jump to @out (we will declare it later) {(codeToExecute)} : replace that with you codeToExecute variable MOV EBX, [{(codeToExecute)}] TEST EBX, 1 JE @out Load the instructions position into EDX Execute our custom instructions Set the value of our returnAdress to the value of EAX -> at this point EAX contains our return-value pointer and we want to save that for later {(codeCaveForInjection)} : replace that with you codeCaveForInjection variable {(returnAdress)} : replace that with you returnAdress variable MOV EDX, {(codeCaveForInjection)} CALL EDX MOV [{(returnAdress)}], EAX Declare our @out anker that we will jump to if there is nothing to execute Set EDX to 0 set the value of codeToExecute to EDX (0) to signal that we are done {(codeToExecute)} : replace that with you codeToExecute variable @out: MOV EDX, 0 MOV [{(codeToExecute)}], EDX Your finished code should now look something like this: PUSHFD PUSHAD MOV EBX, [{(codeToExecute)}] TEST EBX, 1 JE @out MOV EDX, {(codeCaveForInjection)} CALL EDX MOV [{(returnAdress)}], EAX @out: MOV EDX, 0 MOV [{(codeToExecute)}], EDX POPAD POPFD These Instructions will be placed in the first codeCave that we've allocated, you can inject it using Blackmagic like this: BlackMagic.Asm.Clear(); foreach (string s in asm) { BlackMagic.Asm.AddLine(s); } int asmLenght = BlackMagic.Asm.Assemble().Length; BlackMagic.Asm.Inject(codeCave); If you've done all of this there're only two things left to be done: Execute the original endscene stuff Return to the original function BlackMagic.WriteBytes(codeCave + (uint)asmLenght, originalEndscene); BlackMagic.Asm.Clear(); BlackMagic.Asm.AddLine($\"JMP {(endsceneReturnAddress)}\"); BlackMagic.Asm.Inject((codeCave + (uint)asmLenght) + 5); First we are going to place the original EndScene instructions below our injected ones. You should be able to read the original bytes like this: byte[] originalEndscene = BlackMagic.ReadBytes(endscene, 5); or use mine (they might not work for you, first method is safer) byte[] originalEndscene = new byte[] { 0xB8, 0x51, 0xD7, 0xCA, 0x64 }; After this we want to return to the place where we came from: JMP {(endsceneReturnAddress)} uint endsceneReturnAddress = endscene + 5; Now we will return after the instruction that we will replace in a moment to finally hook WoW's EndScene. Let's replace the original instructions with the one that jumps to our codeCave. JMP {(codeCave)} BlackMagic.Asm.Clear(); BlackMagic.Asm.AddLine($\"JMP {(codeCave)}\"); BlackMagic.Asm.Inject(endscene); Congratulations, you hooked WoW's EndScene and it doesn't do anything. But don't worry the hardest part is done, we just need to inject the code we wan't to execute to the codeCaveForInjection and set codeToExecute to 1. to be continued...","title":"Check for instructions to execute"}]}